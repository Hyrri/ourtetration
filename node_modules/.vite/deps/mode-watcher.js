import "./chunk-X7HCJ7ZS.js";
import "./chunk-TE5TN4QG.js";
import {
  derived,
  writable
} from "./chunk-ZAETGQJ4.js";
import {
  HtmlTagHydration,
  SvelteComponentDev,
  add_location,
  append_hydration_dev,
  attr_dev,
  claim_element,
  claim_html_tag,
  detach_dev,
  dispatch_dev,
  element,
  empty,
  get_store_value,
  head_selector,
  init,
  insert_hydration_dev,
  noop,
  onMount,
  safe_not_equal,
  validate_slots
} from "./chunk-ESRVLOOR.js";
import "./chunk-GZA2YTNP.js";
import "./chunk-25V3TAZK.js";

// node_modules/mode-watcher/dist/without-transition.js
var timeoutAction;
var timeoutEnable;
function withoutTransition(action) {
  if (typeof document === "undefined")
    return;
  clearTimeout(timeoutAction);
  clearTimeout(timeoutEnable);
  const style = document.createElement("style");
  const css = document.createTextNode(`* {
     -webkit-transition: none !important;
     -moz-transition: none !important;
     -o-transition: none !important;
     -ms-transition: none !important;
     transition: none !important;
  }`);
  style.appendChild(css);
  const disable = () => document.head.appendChild(style);
  const enable = () => document.head.removeChild(style);
  if (typeof window.getComputedStyle !== "undefined") {
    disable();
    action();
    window.getComputedStyle(style).opacity;
    enable();
    return;
  }
  if (typeof window.requestAnimationFrame !== "undefined") {
    disable();
    action();
    window.requestAnimationFrame(enable);
    return;
  }
  disable();
  timeoutAction = window.setTimeout(() => {
    action();
    timeoutEnable = window.setTimeout(enable, 120);
  }, 120);
}

// node_modules/mode-watcher/dist/stores.js
var noopStorage = {
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  getItem: (_key) => null,
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  setItem: (_key, _value) => {
  }
};
var isBrowser = typeof document !== "undefined";
var modes = ["dark", "light", "system"];
var localStorageKey = "mode-watcher-mode";
var userPrefersMode = createUserPrefersMode();
var systemPrefersMode = createSystemMode();
var themeColors = writable(void 0);
var disableTransitions = writable(true);
var derivedMode = createDerivedMode();
function createUserPrefersMode() {
  const defaultValue = "system";
  const storage = isBrowser ? localStorage : noopStorage;
  const initialValue = storage.getItem(localStorageKey);
  let value = isValidMode(initialValue) ? initialValue : defaultValue;
  const { subscribe, set: _set } = writable(value, () => {
    if (!isBrowser)
      return;
    const handler = (e) => {
      if (e.key !== localStorageKey)
        return;
      const newValue = e.newValue;
      if (isValidMode(newValue)) {
        _set(value = newValue);
      } else {
        _set(value = defaultValue);
      }
    };
    addEventListener("storage", handler);
    return () => removeEventListener("storage", handler);
  });
  function set(v) {
    _set(value = v);
    storage.setItem(localStorageKey, value);
  }
  return {
    subscribe,
    set
  };
}
function createSystemMode() {
  const defaultValue = void 0;
  let track = true;
  const { subscribe, set } = writable(defaultValue, () => {
    if (!isBrowser)
      return;
    const handler = (e) => {
      if (!track)
        return;
      set(e.matches ? "light" : "dark");
    };
    const mediaQueryState = window.matchMedia("(prefers-color-scheme: light)");
    mediaQueryState.addEventListener("change", handler);
    return () => mediaQueryState.removeEventListener("change", handler);
  });
  function query() {
    if (!isBrowser)
      return;
    const mediaQueryState = window.matchMedia("(prefers-color-scheme: light)");
    set(mediaQueryState.matches ? "light" : "dark");
  }
  function tracking(active) {
    track = active;
  }
  return {
    subscribe,
    query,
    tracking
  };
}
function createDerivedMode() {
  const { subscribe } = derived([userPrefersMode, systemPrefersMode, themeColors, disableTransitions], ([$userPrefersMode, $systemPrefersMode, $themeColors, $disableTransitions]) => {
    if (!isBrowser)
      return void 0;
    const derivedMode2 = $userPrefersMode === "system" ? $systemPrefersMode : $userPrefersMode;
    function update() {
      const htmlEl = document.documentElement;
      const themeColorEl = document.querySelector('meta[name="theme-color"]');
      if (derivedMode2 === "light") {
        htmlEl.classList.remove("dark");
        htmlEl.style.colorScheme = "light";
        if (themeColorEl && $themeColors) {
          themeColorEl.setAttribute("content", $themeColors.light);
        }
      } else {
        htmlEl.classList.add("dark");
        htmlEl.style.colorScheme = "dark";
        if (themeColorEl && $themeColors) {
          themeColorEl.setAttribute("content", $themeColors.dark);
        }
      }
    }
    if ($disableTransitions) {
      withoutTransition(update);
    } else {
      update();
    }
    return derivedMode2;
  });
  return {
    subscribe
  };
}
function isValidMode(value) {
  if (typeof value !== "string")
    return false;
  return modes.includes(value);
}

// node_modules/mode-watcher/dist/mode.js
function toggleMode() {
  userPrefersMode.set(get_store_value(derivedMode) === "dark" ? "light" : "dark");
}
function setMode(mode) {
  userPrefersMode.set(mode);
}
function resetMode() {
  userPrefersMode.set("system");
}
function setInitialMode(defaultMode, themeColors2) {
  const rootEl = document.documentElement;
  const mode = localStorage.getItem("mode-watcher-mode") || defaultMode;
  const light = mode === "light" || mode === "system" && window.matchMedia("(prefers-color-scheme: light)").matches;
  rootEl.classList[light ? "remove" : "add"]("dark");
  rootEl.style.colorScheme = light ? "light" : "dark";
  if (themeColors2) {
    const themeMetaEl = document.querySelector('meta[name="theme-color"]');
    if (themeMetaEl) {
      themeMetaEl.setAttribute("content", mode === "light" ? themeColors2.light : themeColors2.dark);
    }
  }
  localStorage.setItem("mode-watcher-mode", mode);
}

// node_modules/mode-watcher/dist/mode-watcher.svelte
var file = "node_modules\\mode-watcher\\dist\\mode-watcher.svelte";
function create_if_block(ctx) {
  let meta;
  let meta_content_value;
  const block = {
    c: function create() {
      meta = element("meta");
      this.h();
    },
    l: function claim(nodes) {
      meta = claim_element(nodes, "META", { name: true, content: true });
      this.h();
    },
    h: function hydrate() {
      attr_dev(meta, "name", "theme-color");
      attr_dev(meta, "content", meta_content_value = /*themeColors*/
      ctx[0].dark);
      add_location(meta, file, 36, 2, 1118);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, meta, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*themeColors*/
      1 && meta_content_value !== (meta_content_value = /*themeColors*/
      ctx2[0].dark)) {
        attr_dev(meta, "content", meta_content_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(meta);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(33:1) {#if themeColors}",
    ctx
  });
  return block;
}
function create_fragment(ctx) {
  let if_block_anchor;
  let html_tag;
  let raw_value = `<script nonce="%sveltekit.nonce%">(` + setInitialMode.toString() + `)(` + /*args*/
  ctx[1] + `);<\/script>`;
  let html_anchor;
  let if_block = (
    /*themeColors*/
    ctx[0] && create_if_block(ctx)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      html_tag = new HtmlTagHydration(false);
      html_anchor = empty();
      this.h();
    },
    l: function claim(nodes) {
      const head_nodes = head_selector("svelte-cpyj77", document.head);
      if (if_block)
        if_block.l(head_nodes);
      if_block_anchor = empty();
      html_tag = claim_html_tag(head_nodes, false);
      html_anchor = empty();
      head_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      html_tag.a = html_anchor;
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(document.head, null);
      append_hydration_dev(document.head, if_block_anchor);
      html_tag.m(raw_value, document.head);
      append_hydration_dev(document.head, html_anchor);
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*themeColors*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        html_tag.d();
      }
      if (if_block)
        if_block.d(detaching);
      detach_dev(if_block_anchor);
      detach_dev(html_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Mode_watcher", slots, []);
  let { track = true } = $$props;
  let { defaultMode = "system" } = $$props;
  let { themeColors: themeColors2 = void 0 } = $$props;
  let { disableTransitions: disableTransitions2 = true } = $$props;
  themeColors.set(themeColors2);
  disableTransitions.set(disableTransitions2);
  onMount(() => {
    const unsubscriber = derivedMode.subscribe(() => {
    });
    systemPrefersMode.tracking(track);
    systemPrefersMode.query();
    const localStorageMode = localStorage.getItem(localStorageKey);
    setMode(isValidMode(localStorageMode) ? localStorageMode : defaultMode);
    return () => {
      unsubscriber();
    };
  });
  const args = `"${defaultMode}"${themeColors2 ? `, ${JSON.stringify(themeColors2)}` : ""}`;
  const writable_props = ["track", "defaultMode", "themeColors", "disableTransitions"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Mode_watcher> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("track" in $$props2)
      $$invalidate(2, track = $$props2.track);
    if ("defaultMode" in $$props2)
      $$invalidate(3, defaultMode = $$props2.defaultMode);
    if ("themeColors" in $$props2)
      $$invalidate(0, themeColors2 = $$props2.themeColors);
    if ("disableTransitions" in $$props2)
      $$invalidate(4, disableTransitions2 = $$props2.disableTransitions);
  };
  $$self.$capture_state = () => ({
    onMount,
    systemPrefersMode,
    setMode,
    localStorageKey,
    mode: derivedMode,
    themeColorsStore: themeColors,
    disableTransitionsStore: disableTransitions,
    setInitialMode,
    isValidMode,
    track,
    defaultMode,
    themeColors: themeColors2,
    disableTransitions: disableTransitions2,
    args
  });
  $$self.$inject_state = ($$props2) => {
    if ("track" in $$props2)
      $$invalidate(2, track = $$props2.track);
    if ("defaultMode" in $$props2)
      $$invalidate(3, defaultMode = $$props2.defaultMode);
    if ("themeColors" in $$props2)
      $$invalidate(0, themeColors2 = $$props2.themeColors);
    if ("disableTransitions" in $$props2)
      $$invalidate(4, disableTransitions2 = $$props2.disableTransitions);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [themeColors2, args, track, defaultMode, disableTransitions2];
}
var Mode_watcher = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment, safe_not_equal, {
      track: 2,
      defaultMode: 3,
      themeColors: 0,
      disableTransitions: 4
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Mode_watcher",
      options,
      id: create_fragment.name
    });
  }
  get track() {
    throw new Error("<Mode_watcher>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set track(value) {
    throw new Error("<Mode_watcher>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get defaultMode() {
    throw new Error("<Mode_watcher>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set defaultMode(value) {
    throw new Error("<Mode_watcher>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get themeColors() {
    throw new Error("<Mode_watcher>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set themeColors(value) {
    throw new Error("<Mode_watcher>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disableTransitions() {
    throw new Error("<Mode_watcher>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disableTransitions(value) {
    throw new Error("<Mode_watcher>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var mode_watcher_default = Mode_watcher;
export {
  mode_watcher_default as ModeWatcher,
  localStorageKey,
  derivedMode as mode,
  resetMode,
  setMode,
  systemPrefersMode,
  toggleMode,
  userPrefersMode
};
//# sourceMappingURL=mode-watcher.js.map
