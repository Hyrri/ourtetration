import "./chunk-X7HCJ7ZS.js";
import "./chunk-TE5TN4QG.js";
import {
  SvelteComponentDev,
  add_location,
  append_hydration_dev,
  assign,
  attr_dev,
  bubble,
  children,
  claim_svg_element,
  compute_rest_props,
  detach_dev,
  dispatch_dev,
  empty,
  exclude_internal_props,
  getContext,
  get_spread_update,
  init,
  insert_hydration_dev,
  listen_dev,
  noop,
  run_all,
  safe_not_equal,
  set_svg_attributes,
  svg_element,
  validate_slots
} from "./chunk-ESRVLOOR.js";
import "./chunk-GZA2YTNP.js";
import "./chunk-25V3TAZK.js";

// node_modules/svelte-radix/dist/Minus.svelte
var file = "C:/Users/STR.HK/3D Objects/OurTetration/node_modules/svelte-radix/dist/Minus.svelte";
function create_else_block(ctx) {
  let svg;
  let path;
  let svg_levels = [
    { width: (
      /*size*/
      ctx[0]
    ) },
    { height: (
      /*size*/
      ctx[0]
    ) },
    /*$$restProps*/
    ctx[5],
    { role: (
      /*role*/
      ctx[1]
    ) },
    { "aria-label": (
      /*ariaLabel*/
      ctx[3]
    ) },
    { viewBox: "0 0 15 15" },
    { fill: (
      /*color*/
      ctx[2]
    ) },
    { xmlns: "http://www.w3.org/2000/svg" }
  ];
  let svg_data = {};
  for (let i = 0; i < svg_levels.length; i += 1) {
    svg_data = assign(svg_data, svg_levels[i]);
  }
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        width: true,
        height: true,
        role: true,
        "aria-label": true,
        viewBox: true,
        fill: true,
        xmlns: true
      });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", {
        "fill-rule": true,
        "clip-rule": true,
        d: true,
        fill: true
      });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "fill-rule", "evenodd");
      attr_dev(path, "clip-rule", "evenodd");
      attr_dev(path, "d", "M2.25 7.5C2.25 7.22386 2.47386 7 2.75 7H12.25C12.5261 7 12.75 7.22386 12.75 7.5C12.75 7.77614 12.5261 8 12.25 8H2.75C2.47386 8 2.25 7.77614 2.25 7.5Z");
      attr_dev(path, "fill", "currentColor");
      add_location(path, file, 48, 4, 1095);
      set_svg_attributes(svg, svg_data);
      add_location(svg, file, 38, 2, 908);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
    },
    p: function update(ctx2, dirty) {
      set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
        dirty & /*size*/
        1 && { width: (
          /*size*/
          ctx2[0]
        ) },
        dirty & /*size*/
        1 && { height: (
          /*size*/
          ctx2[0]
        ) },
        dirty & /*$$restProps*/
        32 && /*$$restProps*/
        ctx2[5],
        dirty & /*role*/
        2 && { role: (
          /*role*/
          ctx2[1]
        ) },
        dirty & /*ariaLabel*/
        8 && { "aria-label": (
          /*ariaLabel*/
          ctx2[3]
        ) },
        { viewBox: "0 0 15 15" },
        dirty & /*color*/
        4 && { fill: (
          /*color*/
          ctx2[2]
        ) },
        { xmlns: "http://www.w3.org/2000/svg" }
      ]));
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block.name,
    type: "else",
    source: "(38:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block(ctx) {
  let svg;
  let path;
  let mounted;
  let dispose;
  let svg_levels = [
    { width: (
      /*size*/
      ctx[0]
    ) },
    { height: (
      /*size*/
      ctx[0]
    ) },
    /*$$restProps*/
    ctx[5],
    { role: (
      /*role*/
      ctx[1]
    ) },
    { "aria-label": (
      /*ariaLabel*/
      ctx[3]
    ) },
    { viewBox: "0 0 15 15" },
    { fill: (
      /*color*/
      ctx[2]
    ) },
    { xmlns: "http://www.w3.org/2000/svg" }
  ];
  let svg_data = {};
  for (let i = 0; i < svg_levels.length; i += 1) {
    svg_data = assign(svg_data, svg_levels[i]);
  }
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        width: true,
        height: true,
        role: true,
        "aria-label": true,
        viewBox: true,
        fill: true,
        xmlns: true
      });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", {
        "fill-rule": true,
        "clip-rule": true,
        d: true,
        fill: true
      });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "fill-rule", "evenodd");
      attr_dev(path, "clip-rule", "evenodd");
      attr_dev(path, "d", "M2.25 7.5C2.25 7.22386 2.47386 7 2.75 7H12.25C12.5261 7 12.75 7.22386 12.75 7.5C12.75 7.77614 12.5261 8 12.25 8H2.75C2.47386 8 2.25 7.77614 2.25 7.5Z");
      attr_dev(path, "fill", "currentColor");
      add_location(path, file, 30, 4, 638);
      set_svg_attributes(svg, svg_data);
      add_location(svg, file, 11, 2, 316);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
      if (!mounted) {
        dispose = [
          listen_dev(
            svg,
            "click",
            /*click_handler*/
            ctx[6],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            svg,
            "keydown",
            /*keydown_handler*/
            ctx[7],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            svg,
            "keyup",
            /*keyup_handler*/
            ctx[8],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            svg,
            "focus",
            /*focus_handler*/
            ctx[9],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            svg,
            "blur",
            /*blur_handler*/
            ctx[10],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            svg,
            "mouseenter",
            /*mouseenter_handler*/
            ctx[11],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            svg,
            "mouseleave",
            /*mouseleave_handler*/
            ctx[12],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            svg,
            "mouseover",
            /*mouseover_handler*/
            ctx[13],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            svg,
            "mouseout",
            /*mouseout_handler*/
            ctx[14],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
        dirty & /*size*/
        1 && { width: (
          /*size*/
          ctx2[0]
        ) },
        dirty & /*size*/
        1 && { height: (
          /*size*/
          ctx2[0]
        ) },
        dirty & /*$$restProps*/
        32 && /*$$restProps*/
        ctx2[5],
        dirty & /*role*/
        2 && { role: (
          /*role*/
          ctx2[1]
        ) },
        dirty & /*ariaLabel*/
        8 && { "aria-label": (
          /*ariaLabel*/
          ctx2[3]
        ) },
        { viewBox: "0 0 15 15" },
        dirty & /*color*/
        4 && { fill: (
          /*color*/
          ctx2[2]
        ) },
        { xmlns: "http://www.w3.org/2000/svg" }
      ]));
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(11:0) {#if withEvents}",
    ctx
  });
  return block;
}
function create_fragment(ctx) {
  let if_block_anchor;
  function select_block_type(ctx2, dirty) {
    if (
      /*withEvents*/
      ctx2[4]
    )
      return create_if_block;
    return create_else_block;
  }
  let current_block_type = select_block_type(ctx, -1);
  let if_block = current_block_type(ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
    },
    p: function update(ctx2, [dirty]) {
      if (current_block_type === (current_block_type = select_block_type(ctx2, dirty)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  const omit_props_names = ["size", "role", "color", "ariaLabel", "withEvents"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Minus", slots, []);
  const ctx = getContext("iconCtx") ?? {};
  let { size = ctx.size || "24" } = $$props;
  let { role = ctx.role || "img" } = $$props;
  let { color = ctx.color || "currentColor" } = $$props;
  let { ariaLabel = "minus," } = $$props;
  let { withEvents = false } = $$props;
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keydown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keyup_handler(event) {
    bubble.call(this, $$self, event);
  }
  function focus_handler(event) {
    bubble.call(this, $$self, event);
  }
  function blur_handler(event) {
    bubble.call(this, $$self, event);
  }
  function mouseenter_handler(event) {
    bubble.call(this, $$self, event);
  }
  function mouseleave_handler(event) {
    bubble.call(this, $$self, event);
  }
  function mouseover_handler(event) {
    bubble.call(this, $$self, event);
  }
  function mouseout_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("size" in $$new_props)
      $$invalidate(0, size = $$new_props.size);
    if ("role" in $$new_props)
      $$invalidate(1, role = $$new_props.role);
    if ("color" in $$new_props)
      $$invalidate(2, color = $$new_props.color);
    if ("ariaLabel" in $$new_props)
      $$invalidate(3, ariaLabel = $$new_props.ariaLabel);
    if ("withEvents" in $$new_props)
      $$invalidate(4, withEvents = $$new_props.withEvents);
  };
  $$self.$capture_state = () => ({
    getContext,
    ctx,
    size,
    role,
    color,
    ariaLabel,
    withEvents
  });
  $$self.$inject_state = ($$new_props) => {
    if ("size" in $$props)
      $$invalidate(0, size = $$new_props.size);
    if ("role" in $$props)
      $$invalidate(1, role = $$new_props.role);
    if ("color" in $$props)
      $$invalidate(2, color = $$new_props.color);
    if ("ariaLabel" in $$props)
      $$invalidate(3, ariaLabel = $$new_props.ariaLabel);
    if ("withEvents" in $$props)
      $$invalidate(4, withEvents = $$new_props.withEvents);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    size,
    role,
    color,
    ariaLabel,
    withEvents,
    $$restProps,
    click_handler,
    keydown_handler,
    keyup_handler,
    focus_handler,
    blur_handler,
    mouseenter_handler,
    mouseleave_handler,
    mouseover_handler,
    mouseout_handler
  ];
}
var Minus = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment, safe_not_equal, {
      size: 0,
      role: 1,
      color: 2,
      ariaLabel: 3,
      withEvents: 4
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Minus",
      options,
      id: create_fragment.name
    });
  }
  get size() {
    throw new Error("<Minus>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<Minus>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get role() {
    throw new Error("<Minus>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set role(value) {
    throw new Error("<Minus>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<Minus>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<Minus>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ariaLabel() {
    throw new Error("<Minus>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ariaLabel(value) {
    throw new Error("<Minus>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get withEvents() {
    throw new Error("<Minus>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set withEvents(value) {
    throw new Error("<Minus>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Minus_default = Minus;
export {
  Minus_default as default
};
//# sourceMappingURL=svelte-radix_Minus__svelte.js.map
